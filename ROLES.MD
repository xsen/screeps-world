### **Техническое Задание: Архитектура Ролей**

Этот документ описывает назначение, логику выполнения и логику автоматического спавна для каждой основной роли крипов в
колонии.

---

### **Ключевые Архитектурные Принципы**

#### **1. Принцип Декомпозиции на Задачи (Task-Oriented Decomposition)**

**Это основной принцип для чистоты и переиспользуемости кода.** Вместо реализации логики действий (например, "найти и
взять ресурс") непосредственно в классе роли, эта логика должна быть инкапсулирована в отдельный, атомарный класс
`Task`.

* **Определение:** `Task` — это класс, реализующий одно конкретное, многократно используемое действие (например,
  `WithdrawFromTarget`, `DeliverEnergyTask`, `BuildTask`).
* **Роль "Дирижера":** Класс `Role` не должен содержать код самого действия (например, `creep.transfer`). Его
  единственная ответственность — определить, **какую** задачу (`Task`) и с **какой** целью (`target`) крип должен
  выполнить в текущий тик.
* **Преимущества:**
  * **DRY (Don't Repeat Yourself):** Устраняет дублирование кода между ролями.
  * **Единая Ответственность (Single Responsibility):** Роли отвечают за принятие решений, а Задачи — за их исполнение.
  * **Гибкость:** Позволяет легко комбинировать и заменять задачи, создавая новое поведение без изменения существующих
    ролей.

#### **2. Приоритетный Список Задач (Priority Task List)**

Большинство ролей, особенно логистических, должны использовать эту архитектуру. Метод `run()` каждой роли каждый тик
формирует список потенциальных задач в порядке приоритета. Как только находится первая выполнимая задача, она
выполняется, и работа на текущий тик завершается.

#### **3. Принцип Валидации Цели (Target Validation Principle)**

**Это критически важный принцип для предотвращения "зацикливания" крипов.** Перед выполнением любой задачи роль *
*обязана** проверить, что текущая цель, сохраненная в памяти крипа (`creep.memory.targetId`), соответствует его текущему
состоянию и задаче.

* **Пример:** Крип `Refiller` только что набрал энергию из `Storage` и стал полным. Его состояние изменилось с "Сбор"
  на "Доставка". Его текущая цель (`Storage`) невалидна для задачи "Доставка". **Цель должна быть немедленно сброшена,**
  чтобы запустить поиск новой, валидной цели (`Extension`).
* **Контр-пример:** Крип `Hauler` только что доставил ресурсы в `Storage` и стал пустым. Его состояние изменилось на "
  Сбор". `Storage` является невалидной целью для задачи "Сбор", и она должна быть немедленно сброшена.

#### **4. Принцип Взаимопомощи Ролей (Role Assistance Principle)**

Для повышения эффективности колонии, крипы, находящиеся в состоянии бездействия (`idle`), могут выполнять задачи других
ролей по строго определенному списку приоритетов. Заимствованная задача всегда имеет **более низкий приоритет**, чем
любая из основных задач роли.

#### **5. Принцип Типизации Памяти Роли (Role-Specific Memory Typing)**

**Это ключевой принцип для поддержания чистоты кода и использования преимуществ TypeScript.** Вместо добавления
опциональных полей в глобальный интерфейс `CreepMemory`, каждая роль, требующая уникального состояния, должна определять
свой собственный, строго типизированный интерфейс памяти.

* **Проблема:** Глобальный `CreepMemory` быстро превращается в "свалку" из опциональных полей (`isAssisting?: boolean`,
  `isUpgrading?: boolean` и т.д.), что делает код запутанным и сложным для поддержки.
* **Решение:** В файле самой роли определяется локальный интерфейс, расширяющий базовый `CreepMemory`, и используется
  приведение типов.
* **Реализация:**
  ```typescript
  // В файле ScavengerRole.ts
  interface ScavengerMemory extends CreepMemory {
    isAssisting?: boolean;
  }

  class ScavengerRole implements CreepRoleHandler {
    public run(creep: Creep): void {
      // Приведение типа в начале метода
      const memory = creep.memory as ScavengerMemory;

      // Теперь можно безопасно работать с memory.isAssisting
      if (memory.isAssisting) {
        // ...
      }
    }
  }
  ```
* **Преимущества:**
  * **Типобезопасность:** Компилятор TypeScript отслеживает ошибки.
  * **Инкапсуляция:** Состояние, специфичное для роли, описывается вместе с самой ролью.
  * **Читаемость:** Код становится самодокументируемым.

---

### **Логистические Роли**

#### **1. `RefillerRole` (Заправщик)**

* **Назначение:** "Скорая помощь" для базы.
* **Логика выполнения (`run`):**
  1. **Доставка:** Выполнить `DeliverRefillEnergyTask` для `Spawn`, `Extension`, `Tower`.
  2. **Сбор:** Выполнить `GatherRefillEnergyTask` для `Storage`, `Container` или `DroppedResource`.
  3. **Ожидание:** Двигаться к `Storage`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Появление первого `Extension` в комнате.
  * **Лимит:** Базовый лимит `1`.
  * **Pre-Spawn:** Для обеспечения бесперебойной работы, если текущий `Refiller` скоро умрет (`ticksToLive <= 50`),
    лимит временно увеличивается до `2` для создания сменщика.
  * **Тело (Штатный режим):** Для плановой замены, тело рассчитывается на **полную** `room.energyCapacityAvailable`.
  * **Тело (Чрезвычайная ситуация):** Если в комнате нет ни одного `Refiller`'а, тело рассчитывается на основе
    `Math.max(room.energyAvailable, 300)`.
  * **Приоритет:** `11`.

#### **2. `HaulerRole` (Перевозчик)**

* **Назначение:** "Рабочая лошадка" экономики.
* **Логика выполнения (`run`):**
  1. **Доставка:** Выполнить `DeliverEnergyTask` **только** для `Storage`.
  2. **Сбор:** Выполнить `GatherHaulEnergyTask`. Эта задача инкапсулирует "умную" логику:

  * Находит **самый полный** `Link` или `Container`.
  * "Захватывает" его в качестве цели.
  * Выполняет новую подзадачу `FillUpFromTargetTask`, которая заставляет крипа оставаться у цели до тех пор, пока он
    не заполнится до отказа, или пока цель не опустеет.
  * Если цель опустела, но есть другие, поиск немедленно повторяется в том же тике.

  3. **Ожидание:** Ждать у `Storage`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Наличие `Storage` и выполнение одного из условий: (1) есть `Source` без `Link`'а рядом, ИЛИ (2) есть
    центральный `Link`.
  * **Сценарий 1 (Есть источники без линков):** Количество и размер перевозчиков рассчитываются динамически на основе
    требуемой пропускной способности от этих источников до `Storage`.
  * **Сценарий 2 (Все источники с линками):** Если есть только центральный `Link` для обслуживания, спавнится **один**
    `Hauler` среднего размера.
  * **Приоритет:** `9`.

#### **3. `ScavengerRole` (Уборщик)**

* **Назначение:** "Оппортунист", сборщик временных ресурсов и помощник.
* **Логика выполнения (`run`):**
  1. **Доставка:** Выполнить `DeliverToTarget` для `Storage`, `Terminal` или `Container`.
  2. **Сбор:** Выполнить `PickupResource` для `DroppedResource` или `WithdrawFromTarget` для `Tombstone`/`Ruin`.
  3. **Взаимопомощь:** Выполнить `GatherHaulEnergyTask`.
  4. **Ожидание:** Ждать у `Storage`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Спавнится **только по тревоге**, если в комнате обнаружены ценные брошенные ресурсы (`amount > 200` или
    не энергия), непустые надгробия (`Tombstone`) или руины (`Ruin`).
  * **Лимит:** `1`.
  * **Тело:** Статичное, маленькое и быстрое (`[4C, 4M]`).
  * **Приоритет:** `12`.

---

### **Прочие Роли**

#### **4. `MinerRole` (Шахтёр)**

* **Назначение:** Стационарная добыча энергии.
* **Логика выполнения (`run`):** Добывает энергию и передает ее в соседний `Link` или `Container`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Создает по одному плану на каждый `Source` в комнате.
  * **Лимит:** `1` на каждый источник. Временно увеличивается до `2`, если текущий майнер скоро умрет.
  * **Тело:** Двухступенчатое. Маленькое (`[2W, 1C, 1M]`) при `energyCapacityAvailable < 700`, и более крупное (
    `[5W, 1C, 3M]`) при `energyCapacityAvailable >= 700`.
  * **Pre-Spawn:** Динамически рассчитывает `preSpawnTicks` на основе расстояния от спавнера до источника.
  * **Приоритет:** `10`.

#### **5. `CommandRole` (Командир)**

* **Назначение:** Выполнение последовательности команд.
* **Логика спавна (`getSpawnPlans`):** **Всегда возвращает пустой массив `[]`**. Эта роль не имеет автоматической логики
  спавна и **всегда** настраивается вручную.

---

### **Роли на базе `SimpleWorkRole`**

**Общий Принцип:** Эти роли наследуют конечный автомат (`working: true/false`) от `SimpleWorkRole`. **Критически важно,
чтобы при смене состояния цель крипа (`targetId`) немедленно сбрасывалась.**

#### **6. `UpgraderRole` (Улучшатель)**

* **Назначение:** Адаптивное улучшение контроллера.
* **Логика выполнения (`findAndExecuteWorkTask`):** Выполняет `UpgradeControllerTask`.
* **Логика спавна (`getSpawnPlans`):**
  * **Принцип:** Логика разделена на 3 основные стадии, зависящие от уровня контроллера и наличия `Storage`.
  * **Стадия 1 (RCL 8):** Если уровень контроллера 8, спавнится один маленький крип (`[W,C,M,M]`) только для поддержания
    таймера, и только если `ticksToDowngrade` опускается ниже 175,000.
  * **Стадия 2 (Ранняя игра, нет `Storage`):** Спавнится по 2 апгрейдера на каждый `Source` в комнате.
  * **Стадия 3 (Основная игра, есть `Storage`):** Лимит и тело крипов зависят от количества энергии в `Storage`:
    * **"Режим Богатства" (`energy > 200k`):** `limit: 2`, тело максимально возможное с упором на `WORK` (до 15 частей).
    * **"Режим Процветания" (`energy > 100k`):** `limit: 1`, тело максимально возможное.
    * **"Режим Экономии" (`energy > 10k`):** `limit: 1`, тело на 50% от `energyCapacityAvailable`.
    * **"Режим Выживания" (`energy <= 10k`):** `limit: 1`, тело минимальное (на 300 энергии).
  * **Приоритет:** `8`.

#### **7. `BuilderRole` (Строитель)**

* **Назначение:** Возведение новых построек.
* **Логика выполнения (`findAndExecuteWorkTask`):** Выполняет `BuildTask`, затем `ExecuteComprehensiveRepairTask`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Наличие хотя бы одного `ConstructionSite` в комнате.
  * **Лимит и Тело:** Адаптивные.
    * Если общий объем работ (`totalProgressNeeded`) большой (`> 20000`), то `limit: 2`, а тело рассчитывается на всю
      доступную энергию.
    * При обычном объеме работ `limit: 1`, а тело "среднее" (на 60% от `energyCapacityAvailable`).
  * **Соотношение частей тела:** 1:1:1 (`WORK`:`CARRY`:`MOVE`).
  * **Приоритет:** `7`.

#### **8. `RepairRole` (Ремонтник)**

* **Назначение:** Поддержание инфраструктуры.
* **Логика выполнения (`findAndExecuteWorkTask`):** Выполняет `ExecuteComprehensiveRepairTask`.
* **Логика спавна (`getSpawnPlans`):**
  * **Триггер:** Наличие поврежденных структур в комнате (проверка кэшируется на 100 тиков).
  * **Лимит:** `1`.
  * **Тело:** "Среднее" (на 60% от `energyCapacityAvailable`) с соотношением `WORK`:`CARRY`:`MOVE` как 1:1:2.
  * **Приоритет:** `7`.

---
**Приоритеты спавна:**

* **11:** `Refiller` (Критический)
* **10:** `Miner` (Критический)
* **9:** `Hauler`, `Scavenger` (Высокий)
* **8:** `Upgrader` (Средний)
* **7:** `Repairer`, `Builder` (Низкий)
* **-:** `Command` (Ручной)
